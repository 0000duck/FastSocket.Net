{"name":"Fastsocket.net","tagline":"c#异步通信库","body":"﻿Overview\r\n========\r\n<p>FastSocket是一个轻量级易扩展的c#异步socket通信库，项目开始于2011年，经过近3年不断调整与改进，目前在功能和性能上均有不错的表现。</p>\r\n<p>项目地址:<a href=\"https://github.com/devhong/FastSocket.Net\">https://github.com/devhong/FastSocket.Net</a>&nbsp;</p>\r\n<p>FastSocket内置了命令行、二进制、thrift协议，基于此开发了Zookeeper, Redis, Thrift等c#异步客户端，接下来将会一一公开。</p>\r\nRequirements\r\n============\r\n.Net 4.0 or Mono 2.6\r\nProjects using FastSocket.Net\r\n============\r\n- <a href=\"https://github.com/devhong/Redis.Driver.Net\">Redis.Driver</a>\r\n- <a href=\"https://github.com/devhong/Zookeeper.Net\">Zookeeper.Net</a>\r\n- <a href=\"https://github.com/devhong/Thrift.Net\">Thrift.Net</a>\r\n\r\nExample Usage\r\n=============\r\n<h3>1: 简单的命令行服务</h3>\r\n<p>新建控制台项目，添加FastSocket.SocketBase,FastSocket.Server引用</p>\r\n<p>自定义服务实现MyService</p>\r\n\r\n```csharp\r\n/// <summary>\r\n/// 实现自定义服务\r\n/// </summary>\r\npublic class MyService : CommandSocketService<StringCommandInfo>\r\n{\r\n    /// <summary>\r\n    /// 当连接时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    public override void OnConnected(IConnection connection)\r\n    {\r\n        base.OnConnected(connection);\r\n        Console.WriteLine(connection.RemoteEndPoint.ToString() + \" connected\");\r\n        connection.BeginSend(PacketBuilder.ToCommandLine(\"welcome\"));\r\n    }\r\n    /// <summary>\r\n    /// 当连接断开时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"ex\"></param>\r\n    public override void OnDisconnected(IConnection connection, Exception ex)\r\n    {\r\n        base.OnDisconnected(connection, ex);\r\n        Console.ForegroundColor = ConsoleColor.Red;\r\n        Console.WriteLine(connection.RemoteEndPoint.ToString() + \" disconnected\");\r\n        Console.ForegroundColor = ConsoleColor.Gray;\r\n    }\r\n    /// <summary>\r\n    /// 当发生错误时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"ex\"></param>\r\n    public override void OnException(IConnection connection, Exception ex)\r\n    {\r\n        base.OnException(connection, ex);\r\n        Console.WriteLine(\"error: \" + ex.ToString());\r\n    }\r\n    /// <summary>\r\n    /// 处理未知命令\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"commandInfo\"></param>\r\n    protected override void HandleUnKnowCommand(IConnection connection, StringCommandInfo commandInfo)\r\n    {\r\n        commandInfo.Reply(connection, \"unknow command:\" + commandInfo.CmdName);\r\n    }\r\n}\r\n```\r\n\r\n<p>Exit命令</p>\r\n```csharp\r\n/// <summary>\r\n/// 退出命令\r\n/// </summary>\r\npublic sealed class ExitCommand : ICommand<StringCommandInfo>\r\n{\r\n    /// <summary>\r\n    /// 返回命令名称\r\n    /// </summary>\r\n    public string Name\r\n    {\r\n        get { return \"exit\"; }\r\n    }\r\n    /// <summary>\r\n    /// 执行命令\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"commandInfo\"></param>\r\n    public void ExecuteCommand(IConnection connection, StringCommandInfo commandInfo)\r\n    {\r\n        connection.BeginDisconnect();//断开连接\r\n    }\r\n}\r\n```\r\n\r\n<p>App.config配置</p>\r\n```xml\r\n<?xml version=\"1.0\"?>\r\n<configuration>\r\n\r\n  <configSections>\r\n    <section name=\"socketServer\"\r\n             type=\"Sodao.FastSocket.Server.Config.SocketServerConfig, FastSocket.Server\"/>\r\n  </configSections>\r\n\r\n  <socketServer>\r\n    <servers>\r\n      <server name=\"cmdline\"\r\n              port=\"8400\"\r\n              socketBufferSize=\"8192\"\r\n              messageBufferSize=\"8192\"\r\n              maxMessageSize=\"102400\"\r\n              maxConnections=\"20000\"\r\n              serviceType=\"CommandLine.MyService, CommandLine\"\r\n              protocol=\"commandLine\"/>\r\n    </servers>\r\n  </socketServer>\r\n\r\n</configuration>\r\n```\r\n\r\n<p>初始化及启动服务</p>\r\n```csharp\r\nstatic void Main(string[] args)\r\n{\r\n    SocketServerManager.Init();\r\n    SocketServerManager.Start();\r\n\r\n    Console.ReadLine();\r\n}\r\n```\r\n\r\n<p>启动服务，然后在cmd中运行telnet 127.0.0.1 8400, 运行截图如下：</p>\r\n<p><img src=\"http://images.cnitblog.com/blog/21702/201308/15220257-a74cd62ae2c64d5eb4da160d44212272.png\" alt=\"\" /></p>\r\n<p><img src=\"http://images.cnitblog.com/blog/21702/201308/15220409-b328d92f13d94c45b0a06452b2930d5a.png\" alt=\"\" /></p>\r\n<p>其中welcome中当连接建立时服务端发送到终端的。</p>\r\n<p>connection.BeginSend(PacketBuilder.ToCommandLine(\"welcome\"));</p>\r\n<p>unknow command:Hello是因为没有对应的\"Hello\"命令实现由HandleUnKnowCommand输出的</p>\r\n```csharp\r\nprotected override void HandleUnKnowCommand(IConnection connection, StringCommandInfo commandInfo)\r\n{\r\n    commandInfo.Reply(connection, \"unknow command:\" + commandInfo.CmdName);\r\n}\r\n```\r\n<p>当在终端中键入exit时，触发了ExitCommand.ExecuteCommand方法，服务端主动断开连接，终端退出。</p>\r\n\r\n\r\n<h3>2: 在服务中使用自定义二进制协议</h3>\r\n\r\n<div>新建控制台项目，命名为Server</div>\r\n<div>添加FastSocket.SocketBase,FastSocket.Server引用</div>\r\n\r\n<div>Socket命令服务类: Sodao.FastSocket.Server.CommandSocketService泛型类</div>\r\n<div>其中需要实现Socket连接，断开，异常，发送完回调及处理未知命令的方法</div>\r\n\r\n<div>内置的二进制命令对象: Sodao.FatSocket.Server.Command.AsyncBinaryCommandInfo</div>\r\n<div>由一个command name,一个唯一标识SeqId和主题内容buffer构建。</div>\r\n\r\n<div>定义服务类MyService继承CommandSocketService类，</div>\r\n<div>泛型类型为上述的AsyncBinanryCommandInfo</div>\r\n</p>\r\n\r\n```csharp\r\n/// <summary>\r\n/// 实现自定义服务\r\n/// </summary>\r\npublic class MyService : CommandSocketService<AsyncBinaryCommandInfo>\r\n{\r\n    /// <summary>\r\n    /// 当连接时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    public override void OnConnected(IConnection connection)\r\n    {\r\n        base.OnConnected(connection);\r\n        Console.WriteLine(connection.RemoteEndPoint.ToString() + \" connected\");\r\n    }\r\n    /// <summary>\r\n    /// 当连接断开时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"ex\"></param>\r\n    public override void OnDisconnected(IConnection connection, Exception ex)\r\n    {\r\n        base.OnDisconnected(connection, ex);\r\n        Console.ForegroundColor = ConsoleColor.Red;\r\n        Console.WriteLine(connection.RemoteEndPoint.ToString() + \" disconnected\");\r\n        Console.ForegroundColor = ConsoleColor.Gray;\r\n    }\r\n    /// <summary>\r\n    /// 当发生错误时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"ex\"></param>\r\n    public override void OnException(IConnection connection, Exception ex)\r\n    {\r\n        base.OnException(connection, ex);\r\n        Console.WriteLine(\"error: \" + ex.ToString());\r\n    }\r\n    /// <summary>\r\n    /// 当服务端发送Packet完毕会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"e\"></param>\r\n    public override void OnSendCallback(IConnection connection, SendCallbackEventArgs e)\r\n    {\r\n        base.OnSendCallback(connection, e);\r\n        Console.ForegroundColor = ConsoleColor.Green;\r\n        Console.WriteLine(\"send \" + e.Status.ToString());\r\n        Console.ForegroundColor = ConsoleColor.Gray;\r\n    }\r\n    /// <summary>\r\n    /// 处理未知的命令\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"commandInfo\"></param>\r\n    protected override void HandleUnKnowCommand(IConnection connection, AsyncBinaryCommandInfo commandInfo)\r\n    {\r\n        Console.WriteLine(\"unknow command: \" + commandInfo.CmdName);\r\n    }\r\n}\r\n```\r\n\r\n<div>实现一个命令如示例项目中的SumCommand类，命令类需要实现ICommand泛型接口</div>\r\n<div>即服务中可以进行处理的服务契约</div>\r\n<div>而泛型类型即上述的AsyncBinaryCommandInfo</div>\r\n\r\n```csharp\r\n/// <summary>\r\n/// sum command\r\n/// 用于将一组int32数字求和并返回\r\n/// </summary>\r\npublic sealed class SumCommand : ICommand<AsyncBinaryCommandInfo>\r\n{\r\n    /// <summary>\r\n    /// 返回服务名称\r\n    /// </summary>\r\n    public string Name\r\n    {\r\n        get { return \"sum\"; }\r\n    }\r\n    /// <summary>\r\n    /// 执行命令并返回结果\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"commandInfo\"></param>\r\n    public void ExecuteCommand(IConnection connection, AsyncBinaryCommandInfo commandInfo)\r\n    {\r\n        if (commandInfo.Buffer == null || commandInfo.Buffer.Length == 0)\r\n        {\r\n            Console.WriteLine(\"sum参数为空\");\r\n            connection.BeginDisconnect();\r\n            return;\r\n        }\r\n        if (commandInfo.Buffer.Length % 4 != 0)\r\n        {\r\n            Console.WriteLine(\"sum参数错误\");\r\n            connection.BeginDisconnect();\r\n            return;\r\n        }\r\n\r\n        int skip = 0;\r\n        var arr = new int[commandInfo.Buffer.Length / 4];\r\n        for (int i = 0, l = arr.Length; i < l; i++)\r\n        {\r\n            arr[i] = BitConverter.ToInt32(commandInfo.Buffer, skip);\r\n            skip += 4;\r\n        }\r\n\r\n        commandInfo.Reply(connection, BitConverter.GetBytes(arr.Sum()));\r\n    }\r\n}\r\n```\r\napp.config\r\n```xml\r\n<?xml version=\"1.0\"?>\r\n<configuration>\r\n\r\n  <configSections>\r\n    <section name=\"socketServer\"\r\n             type=\"Sodao.FastSocket.Server.Config.SocketServerConfig, FastSocket.Server\"/>\r\n  </configSections>\r\n\r\n  <socketServer>\r\n    <servers>\r\n      <server name=\"binary\"\r\n              port=\"8401\"\r\n              socketBufferSize=\"8192\"\r\n              messageBufferSize=\"8192\"\r\n              maxMessageSize=\"102400\"\r\n              maxConnections=\"20000\"\r\n              serviceType=\"Server.MyService, Server\"\r\n              protocol=\"asyncBinary\"/>\r\n    </servers>\r\n  </socketServer>\r\n\r\n</configuration>\r\n```\r\n\r\n<div>其中section name=\"socketServer\" 为服务端默认读取的sectionName</div>\r\n<div>type为反射自FastSocket.Server中的config类型</div>\r\n<div>server配置中，name自定，serviceType为上述实现的服务类反射类型</div>\r\n<div>协议名为asyncBinary</div>\r\n\r\n<div>在Main函数中启动服务</div>\r\n</p>\r\n```csharp\r\nstatic void Main(string[] args)\r\n{\r\n    SocketServerManager.Init();\r\n    SocketServerManager.Start();\r\n\r\n    Console.ReadLine();\r\n}\r\n```\r\n\r\n<div>新建控制台应用程序，命名为Client</div>\r\n<div>添加FastSocket.Client,FastSocket.SocketBase引用</div>\r\n\r\n<div>客户端的代码为组织命令向服务端请求</div>\r\n<div>创建一个Sodao.FastSocket.Client.AsyncBinarySocketClient的实例</div>\r\n<div>并通过RegisterServerNode来注册服务端节点，需要注意name必须唯一</div>\r\n<div>并且地址为我们服务端运行的地址，端口为服务端配置文件中配置的端口号</div>\r\n```csharp\r\nstatic void Main(string[] args)\r\n{\r\n    var client = new Sodao.FastSocket.Client.AsyncBinarySocketClient(8192, 8192, 3000, 3000);\r\n    //注册服务器节点，这里可注册多个(name不能重复）\r\n    client.RegisterServerNode(\"127.0.0.1:8401\", new System.Net.IPEndPoint(System.Net.IPAddress.Parse(\"127.0.0.1\"), 8401));\r\n    //client.RegisterServerNode(\"127.0.0.1:8402\", new System.Net.IPEndPoint(System.Net.IPAddress.Parse(\"127.0.0.2\"), 8401));\r\n\r\n    //组织sum参数, 格式为<<i:32-limit-endian,....N>>\r\n    //这里的参数其实也可以使用thrift, protobuf, bson, json等进行序列化，\r\n    byte[] bytes = null;\r\n    using (var ms = new System.IO.MemoryStream())\r\n    {\r\n        for (int i = 1; i <= 1000; i++) ms.Write(BitConverter.GetBytes(i), 0, 4);\r\n        bytes = ms.ToArray();\r\n    }\r\n    //发送sum命令\r\n    client.Send(\"sum\", bytes, res => BitConverter.ToInt32(res.Buffer, 0)).ContinueWith(c =>\r\n    {\r\n        if (c.IsFaulted)\r\n        {\r\n            Console.WriteLine(c.Exception.ToString());\r\n            return;\r\n        }\r\n        Console.WriteLine(c.Result);\r\n    });\r\n\r\n    Console.ReadLine();\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}