{"name":"Fastsocket.net","tagline":"c#异步通信库","body":"﻿Overview\r\n========\r\n<p>FastSocket是一个轻量级易扩展的c#异步socket通信库，项目开始于2011年，经过近3年不断调整与改进，目前在功能和性能上均有不错的表现。</p>\r\n<p>项目地址:<a href=\"https://github.com/devhong/FastSocket.Net\">https://github.com/devhong/FastSocket.Net</a>&nbsp;</p>\r\n<p>FastSocket内置了命令行、二进制、thrift协议，基于此开发了Zookeeper, Redis, Thrift等c#异步客户端，接下来将会一一公开。</p>\r\nRequirements\r\n============\r\n.Net 4.0 or Mono 2.6\r\nProjects using FastSocket.Net\r\n============\r\n- <a href=\"https://github.com/devhong/Redis.Driver.Net\">Redis.Driver</a>\r\n- <a href=\"https://github.com/devhong/Zookeeper.Net\">Zookeeper.Net</a>\r\n- <a href=\"https://github.com/devhong/Thrift.Net\">Thrift.Net</a>\r\n\r\nExample Usage\r\n=============\r\n<p><span style=\"font-family: 黑体; font-size: 14pt; line-height: 1.5;\">简单的命令行服务</span></p>\r\n<p><span style=\"font-size: 14pt; font-family: 黑体;\"><span style=\"font-size: 13px;\">新建控制台项目，添加FastSocket.SocketBase,FastSocket.Server引用</span><br /></span></p>\r\n<p><span style=\"font-size: 14pt; font-family: 黑体;\"><span style=\"font-size: 13px;\">自定义服务实现MyService</span></span></p>\r\n\r\n```csharp\r\n/// <summary>\r\n/// 实现自定义服务\r\n/// </summary>\r\npublic class MyService : CommandSocketService<StringCommandInfo>\r\n{\r\n    /// <summary>\r\n    /// 当连接时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    public override void OnConnected(IConnection connection)\r\n    {\r\n        base.OnConnected(connection);\r\n        Console.WriteLine(connection.RemoteEndPoint.ToString() + \" connected\");\r\n        connection.BeginSend(PacketBuilder.ToCommandLine(\"welcome\"));\r\n    }\r\n    /// <summary>\r\n    /// 当连接断开时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"ex\"></param>\r\n    public override void OnDisconnected(IConnection connection, Exception ex)\r\n    {\r\n        base.OnDisconnected(connection, ex);\r\n        Console.ForegroundColor = ConsoleColor.Red;\r\n        Console.WriteLine(connection.RemoteEndPoint.ToString() + \" disconnected\");\r\n        Console.ForegroundColor = ConsoleColor.Gray;\r\n    }\r\n    /// <summary>\r\n    /// 当发生错误时会调用此方法\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"ex\"></param>\r\n    public override void OnException(IConnection connection, Exception ex)\r\n    {\r\n        base.OnException(connection, ex);\r\n        Console.WriteLine(\"error: \" + ex.ToString());\r\n    }\r\n    /// <summary>\r\n    /// 处理未知命令\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"commandInfo\"></param>\r\n    protected override void HandleUnKnowCommand(IConnection connection, StringCommandInfo commandInfo)\r\n    {\r\n        commandInfo.Reply(connection, \"unknow command:\" + commandInfo.CmdName);\r\n    }\r\n}\r\n```\r\n\r\n<p>Exit命令</p>\r\n```csharp\r\n/// <summary>\r\n/// 退出命令\r\n/// </summary>\r\npublic sealed class ExitCommand : ICommand<StringCommandInfo>\r\n{\r\n    /// <summary>\r\n    /// 返回命令名称\r\n    /// </summary>\r\n    public string Name\r\n    {\r\n        get { return \"exit\"; }\r\n    }\r\n    /// <summary>\r\n    /// 执行命令\r\n    /// </summary>\r\n    /// <param name=\"connection\"></param>\r\n    /// <param name=\"commandInfo\"></param>\r\n    public void ExecuteCommand(IConnection connection, StringCommandInfo commandInfo)\r\n    {\r\n        connection.BeginDisconnect();//断开连接\r\n    }\r\n}\r\n```\r\n\r\n<p>App.config配置</p>\r\n```xml\r\n<?xml version=\"1.0\"?>\r\n<configuration>\r\n\r\n  <configSections>\r\n    <section name=\"socketServer\"\r\n             type=\"Sodao.FastSocket.Server.Config.SocketServerConfig, FastSocket.Server_1.0\"/>\r\n  </configSections>\r\n\r\n  <socketServer>\r\n    <servers>\r\n      <server name=\"cmdline\"\r\n              port=\"8400\"\r\n              socketBufferSize=\"8192\"\r\n              messageBufferSize=\"8192\"\r\n              maxMessageSize=\"102400\"\r\n              maxConnections=\"20000\"\r\n              serviceType=\"CommandLine.MyService, CommandLine\"\r\n              protocol=\"commandLine\"/>\r\n    </servers>\r\n  </socketServer>\r\n\r\n</configuration>\r\n```\r\n\r\n<p>初始化及启动服务</p>\r\n```csharp\r\nstatic void Main(string[] args)\r\n{\r\n    SocketServerManager.Init();\r\n    SocketServerManager.Start();\r\n\r\n    Console.ReadLine();\r\n}\r\n```\r\n\r\n<p>启动服务，然后在cmd中运行telnet 127.0.0.1 8400, 运行截图如下：</p>\r\n<p><img src=\"http://images.cnitblog.com/blog/21702/201308/15220257-a74cd62ae2c64d5eb4da160d44212272.png\" alt=\"\" /></p>\r\n<p><img src=\"http://images.cnitblog.com/blog/21702/201308/15220409-b328d92f13d94c45b0a06452b2930d5a.png\" alt=\"\" /></p>\r\n<p>其中welcome中当连接建立时服务端发送到终端的。</p>\r\n<p>connection.BeginSend(PacketBuilder.ToCommandLine(\"welcome\"));</p>\r\n<p>unknow command:Hello是因为没有对应的\"Hello\"命令实现由HandleUnKnowCommand输出的</p>\r\n```csharp\r\nprotected override void HandleUnKnowCommand(IConnection connection, StringCommandInfo commandInfo)\r\n{\r\n    commandInfo.Reply(connection, \"unknow command:\" + commandInfo.CmdName);\r\n}\r\n```\r\n<p>当在终端中键入exit时，触发了ExitCommand.ExecuteCommand方法，服务端主动断开连接，终端退出。</p>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}